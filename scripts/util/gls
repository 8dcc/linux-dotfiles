#!/usr/bin/env bash
#
# Copyright 2025 8dcc
#
# This file is part of 8dcc's Linux dotfiles.
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# this program. If not, see <https://www.gnu.org/licenses/>.
set -e

# Find the target directory from arguments (last non-flag arg, or PWD)
target=""
for arg in "$@"; do
    [[ "$arg" != -* ]] && target="$arg"
done
target="${target:-.}"

# Resolve to absolute path; if target is a file, use its parent
if [[ -f "$target" ]]; then
    target=$(cd "$(dirname "$target")" 2>/dev/null && pwd)
elif [[ -d "$target" ]]; then
    target=$(cd "$target" 2>/dev/null && pwd)
else
    exec ls -l "$@"
fi

# If not in a git repo, just run ls -l
if ! git -C "$target" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    exec ls -l "$@"
fi

root=$(git -C "$target" rev-parse --show-toplevel)

prefix=""
if [[ "$target" != "$root" ]]; then
    prefix="${target#$root/}/"
fi

declare -A status_map=()

while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    code="${line:0:2}"
    file="${line:3}"
    file="${file%% ->*}"
    status_map["$file"]="$code"
done < <(git -C "$root" status --porcelain --untracked-files=all --ignored 2>/dev/null)

ls -l --color=always "$@" | while IFS= read -r line; do
    # Strip ANSI escape codes to parse fields
    clean=$(printf '%s' "$line" | sed 's/\x1b\[[0-9;]*m//g')
    filename=$(printf '%s' "$clean" | awk '{for(i=9;i<=NF;i++) printf (i>9?" ":"") $i; print ""}')

    # Lines without a filename (e.g. "total 128")
    if [[ -z "$filename" ]]; then
        printf '     %s\n' "$line"
        continue
    fi

    # Strip symlink target for lookup
    base="${filename%% -> *}"
    key="$prefix$base"
    code="${status_map[$key]:-  }"

    color=""
    case "$code" in
        "M "|" M"|"MM"|"AM") color="\033[33m" ;;  # yellow  - modified
        "A "|"AC")           color="\033[32m" ;;  # green   - staged/added
        "D "|" D"|"AD")      color="\033[31m" ;;  # red     - deleted
        "??")                color="\033[36m" ;;  # cyan    - untracked
        "!!")                color="\033[90m" ;;  # gray    - ignored
        "R "|"RM")           color="\033[35m" ;;  # magenta - renamed
    esac

    printf ' %b%-2s\033[0m %s\n' "$color" "$code" "$line"
done
