#!/usr/bin/env bash
#
# Copyright 2025 8dcc
#
# This file is part of 8dcc's Linux dotfiles.
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# this program. If not, see <https://www.gnu.org/licenses/>.
set -e

# Verify required tools and versions
if (( BASH_VERSINFO[0] < 4 )); then
    echo "gls: requires bash 4.0+ (for associative arrays), found $BASH_VERSION" >&2
    exit 1
fi

for cmd in git sed ls; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
        echo "gls: required command '$cmd' not found" >&2
        exit 1
    fi
done

if ! ls --version 2>/dev/null | grep -q 'GNU coreutils'; then
    echo "gls: requires GNU ls (coreutils)" >&2
    exit 1
fi

git_version=$(git --version | grep -oP '\d+\.\d+')
git_major=${git_version%%.*}
git_minor=${git_version#*.}
if (( git_major < 2 || (git_major == 2 && git_minor < 17) )); then
    echo "gls: requires git 2.17+ (for --ignored=matching), found $(git --version)" >&2
    exit 1
fi

LS_FLAGS=(-l --sort=version --group-directories-first --human-readable
          --time-style=+"$(echo -e '%Y.%m.%d %R')")

# Find the target directory from arguments (last non-flag arg, or PWD)
target=""
for arg in "$@"; do
    [[ "$arg" != -* ]] && target="$arg"
done
target="${target:-.}"

# Resolve to absolute path; if target is a file, use its parent
if [[ -f "$target" ]]; then
    target=$(cd "$(dirname "$target")" 2>/dev/null && pwd)
elif [[ -d "$target" ]]; then
    target=$(cd "$target" 2>/dev/null && pwd)
else
    exec ls "${LS_FLAGS[@]}" --color=auto "$@"
fi

# If not in a git repo, just run ls
if ! git -C "$target" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    exec ls "${LS_FLAGS[@]}" --color=auto "$@"
fi

root=$(git -C "$target" rev-parse --show-toplevel)

path_prefix=""
if [[ "$target" != "$root" ]]; then
    path_prefix="${target#$root/}/"
fi

declare -A status_map=()
declare -A dir_status_map=()

# Priority table for propagating status to parent directories.
# Higher value wins when multiple children have different statuses.
declare -A status_pri=(
    ["??"]=5
    [" M"]=4 [" D"]=4 [" T"]=4 ["MM"]=4 ["MD"]=4 ["MT"]=4
    ["M "]=4 ["AM"]=4 ["AD"]=4 ["AT"]=4
    ["A "]=3 ["AC"]=3 ["AT"]=3
    ["D "]=3 ["R "]=3 ["RM"]=3 ["RD"]=3 ["RT"]=3
)

while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    code="${line:0:2}"
    file="${line:3}"
    file="${file%% ->*}"
    file="${file%/}"
    status_map["$file"]="$code"
done < <(git -C "$root" status --porcelain --untracked-files=normal --ignored=matching 2>/dev/null)

# Propagate file statuses upward to parent directories
for file in "${!status_map[@]}"; do
    code="${status_map[$file]}"

    # The "ignored" status doesn't propagate upwards; it should only be shown
    # on the ignored file/directory itself.
    [[ "$code" == "!!" ]] && continue

    pri=${status_pri[$code]:-2}
    dir="$file"
    while [[ "$dir" == */* ]]; do
        dir="${dir%/*}"
        existing="${dir_status_map[$dir]:-}"
        if [[ -z "$existing" ]]; then
            dir_status_map["$dir"]="$code"
        else
            existing_pri=${status_pri[$existing]:-2}
            (( pri > existing_pri )) && dir_status_map["$dir"]="$code"
        fi
    done
done

ls "${LS_FLAGS[@]}" --color=always "$@" | while IFS= read -r line; do
    # Strip ANSI escape codes to parse fields
    clean=$(printf '%s' "$line" | sed 's/\x1b\[[0-9;]*m//g')

    # Match everything up to the HH:MM time field to split prefix/filename
    if [[ "$clean" =~ ^(.*[0-9]{2}:[0-9]{2})[[:space:]]+(.*) ]]; then
        line_prefix="${BASH_REMATCH[1]}"
        filename="${BASH_REMATCH[2]}"
    else
        # Not a file line (e.g. "total 128")
        echo "$line"
        continue
    fi

    # Strip symlink target for lookup
    base="${filename%% -> *}"
    key="$path_prefix$base"
    code="${status_map[$key]:-}"
    # For directories, check the propagated status from descendants
    if [[ -z "$code" ]]; then
        code="${dir_status_map[$key]:-  }"
    fi

    # Get the color from the code. Code table from the man-page of
    # git-status(1):
    #
    #   | X        | Y      | Meaning                               |
    #   |----------+--------+---------------------------------------|
    #   |          | [AMD]  | not updated                           |
    #   | M        | [ MTD] | updated in index                      |
    #   | T        | [ MTD] | type changed in index                 |
    #   | A        | [ MTD] | added to index                        |
    #   | D        |        | deleted from index                    |
    #   | R        | [ MTD] | renamed in index                      |
    #   | C        | [ MTD] | copied in index                       |
    #   | [MTARC]  |        | index and work tree matches           |
    #   | [ MTARC] | M      | work tree changed since index         |
    #   | [ MTARC] | T      | type changed in work tree since index |
    #   | [ MTARC] | D      | deleted in work tree                  |
    #   |          | R      | renamed in work tree                  |
    #   |          | C      | copied in work tree                   |
    #   |----------+--------+---------------------------------------|
    #   | D        | D      | unmerged, both deleted                |
    #   | A        | U      | unmerged, added by us                 |
    #   | U        | D      | unmerged, deleted by them             |
    #   | U        | A      | unmerged, added by them               |
    #   | D        | U      | unmerged, deleted by us               |
    #   | A        | A      | unmerged, both added                  |
    #   | U        | U      | unmerged, both modified               |
    #   |----------+--------+---------------------------------------|
    #   | ?        | ?      | untracked                             |
    #   | !        | !      | ignored                               |
    #
    color=""
    case "$code" in
        "M "|" M"|"MM"|"AM") color="\033[33m" ;;  # yellow  - modified
        "A "|"AC")           color="\033[32m" ;;  # green   - staged/added
        "D "|" D"|"AD")      color="\033[31m" ;;  # red     - deleted
        "??")                color="\033[36m" ;;  # cyan    - untracked
        "!!")                color="\033[90m" ;;  # gray    - ignored
        "R "|"RM")           color="\033[35m" ;;  # magenta - renamed
    esac

    # Extract the colored filename from the original line.
    # The prefix (perms, owner, size, date) has no ANSI codes, so byte
    # positions match between the clean and colored versions.
    colored_rest="${line:${#line_prefix}}"
    colored_rest="${colored_rest#"${colored_rest%%[! ]*}"}"

    printf '%s %b%-2s\033[0m %s\n' "$line_prefix" "$color" "$code" "$colored_rest"
done
