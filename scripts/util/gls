#!/usr/bin/env bash
#
# Copyright 2025 8dcc
#
# This file is part of 8dcc's Linux dotfiles.
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# this program. If not, see <https://www.gnu.org/licenses/>.
set -e

LS_FLAGS=(-l --sort=version --group-directories-first --human-readable
          --time-style=+"$(echo -e '%Y.%m.%d %R')")

# Find the target directory from arguments (last non-flag arg, or PWD)
target=""
for arg in "$@"; do
    [[ "$arg" != -* ]] && target="$arg"
done
target="${target:-.}"

# Resolve to absolute path; if target is a file, use its parent
if [[ -f "$target" ]]; then
    target=$(cd "$(dirname "$target")" 2>/dev/null && pwd)
elif [[ -d "$target" ]]; then
    target=$(cd "$target" 2>/dev/null && pwd)
else
    exec ls "${LS_FLAGS[@]}" --color=auto "$@"
fi

# If not in a git repo, just run ls
if ! git -C "$target" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    exec ls "${LS_FLAGS[@]}" --color=auto "$@"
fi

root=$(git -C "$target" rev-parse --show-toplevel)

path_prefix=""
if [[ "$target" != "$root" ]]; then
    path_prefix="${target#$root/}/"
fi

declare -A status_map=()

while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    code="${line:0:2}"
    file="${line:3}"
    file="${file%% ->*}"
    status_map["$file"]="$code"
done < <(git -C "$root" status --porcelain --untracked-files=all --ignored 2>/dev/null)

ls "${LS_FLAGS[@]}" --color=always "$@" | while IFS= read -r line; do
    # Strip ANSI escape codes to parse fields
    clean=$(printf '%s' "$line" | sed 's/\x1b\[[0-9;]*m//g')

    # Match everything up to the HH:MM time field to split prefix/filename
    if [[ "$clean" =~ ^(.*[0-9]{2}:[0-9]{2})[[:space:]]+(.*) ]]; then
        line_prefix="${BASH_REMATCH[1]}"
        filename="${BASH_REMATCH[2]}"
    else
        # Not a file line (e.g. "total 128")
        echo "$line"
        continue
    fi

    # Strip symlink target for lookup
    base="${filename%% -> *}"
    key="$path_prefix$base"
    code="${status_map[$key]:-  }"

    # Get the color from the code. Code table from the man-page of
    # git-status(1):
    #
    #   | X        | Y      | Meaning                               |
    #   |----------+--------+---------------------------------------|
    #   |          | [AMD]  | not updated                           |
    #   | M        | [ MTD] | updated in index                      |
    #   | T        | [ MTD] | type changed in index                 |
    #   | A        | [ MTD] | added to index                        |
    #   | D        |        | deleted from index                    |
    #   | R        | [ MTD] | renamed in index                      |
    #   | C        | [ MTD] | copied in index                       |
    #   | [MTARC]  |        | index and work tree matches           |
    #   | [ MTARC] | M      | work tree changed since index         |
    #   | [ MTARC] | T      | type changed in work tree since index |
    #   | [ MTARC] | D      | deleted in work tree                  |
    #   |          | R      | renamed in work tree                  |
    #   |          | C      | copied in work tree                   |
    #   |----------+--------+---------------------------------------|
    #   | D        | D      | unmerged, both deleted                |
    #   | A        | U      | unmerged, added by us                 |
    #   | U        | D      | unmerged, deleted by them             |
    #   | U        | A      | unmerged, added by them               |
    #   | D        | U      | unmerged, deleted by us               |
    #   | A        | A      | unmerged, both added                  |
    #   | U        | U      | unmerged, both modified               |
    #   |----------+--------+---------------------------------------|
    #   | ?        | ?      | untracked                             |
    #   | !        | !      | ignored                               |
    #
    color=""
    case "$code" in
        "M "|" M"|"MM"|"AM") color="\033[33m" ;;  # yellow  - modified
        "A "|"AC")           color="\033[32m" ;;  # green   - staged/added
        "D "|" D"|"AD")      color="\033[31m" ;;  # red     - deleted
        "??")                color="\033[36m" ;;  # cyan    - untracked
        "!!")                color="\033[90m" ;;  # gray    - ignored
        "R "|"RM")           color="\033[35m" ;;  # magenta - renamed
    esac

    # Extract the colored filename from the original line.
    # The prefix (perms, owner, size, date) has no ANSI codes, so byte
    # positions match between the clean and colored versions.
    colored_rest="${line:${#line_prefix}}"
    colored_rest="${colored_rest#"${colored_rest%%[! ]*}"}"

    printf '%s %b%-2s\033[0m %s\n' "$line_prefix" "$color" "$code" "$colored_rest"
done
